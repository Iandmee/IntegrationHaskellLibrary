# IntegrationHaskellLibrary

## Постановка задачи
Минимум:

-   Библиотека
-   Пользователь задает допустимую ошибку и определенный интеграл как функцию на хаскелле
-   Реализуете 3 метода вычисления определенного интеграла
-   Обработка ошибок
-   Юнит-тесты

Дополнительные задачи:

-   Консольный (или другой пользовательский) интерфейс, где пользователь может задать определенный интеграл и получить ответ, не кодя на хаскелле
-   Вычисление ошибок и того, сколько шагов потребовалось, чтобы достичь результата
-   Сравнение трех методов между собой
-   Property-based тестирование

## Выполнено
Всё без консольного интерфейса

## Архитектура & Реализация

Основная логика приложения (которая предоставляет возможность вычисления определённых интегралов 3-мя различными способами) спрятана в файле `Internal.hs`. 
Файл `Integration.hs` - предоставляет пользовательский интерфейс библиотекой, где есть соответствующие 3 функции, для вычисления определённых интегралов. 
Также реализовано сравнение методов с помощью изображения диаграмы, логика которого находится в `comparison/Main.hs`. На выходе получается изображение, на котором в зависимости от заданого предельного значения ошибки отмечены точки, значения интегралов, посчитанные различными методами.
Для тестирования были выбраны методы `Unit` и `Property based` тестирования, которые располагаются в файлах  `Unit` и `PropertyBasedTest` соответственно. 

Сама логика вычисления интеграла с заданной ошибкой использует в себе *Правило Рунге*, опираясь на него, мы можем гарантировать, что требуемая точность будет достигнута, если это вообще возможно. 

Для того, чтобы задавать функции, которые понимает библиотека, требуется представлять функцию в виде специальной структуры `Expr`.

## Библиотеки

Для реализации тестирования были выбраны библиотеки `HUnit`  и `Hedgehog`. 
Для реализации генерирования диаграммы была использована библиотека `matplotlib`, так как внутри неё изпользуется питон, что упрощает сложность с предварительной установкой библиотек, по сравнению с аналогами.

## Выводы
-  $f(x) = \sqrt(x) + e^x$
<br>
 <img src="https://github.com/Iandmee/IntegrationHaskellLibrary/blob/main/img/comparison1.png" alt="alt text" title="image Title" width="450"/>

- $f(x) = \sqrt(x) + e^{x^2}$ 
<br>
 <img src="https://github.com/Iandmee/IntegrationHaskellLibrary/blob/main/img/comparison2.png" alt="alt text" title="image Title" width="450"/>

- $f(x) = \sqrt(x) + e^{x^3}$
<br>
 <img src="https://github.com/Iandmee/IntegrationHaskellLibrary/blob/main/img/comparison3.png" alt="alt text" title="image Title" width="450"/>

- $f(x) = \sqrt(x)$
<br>
 <img src="https://github.com/Iandmee/IntegrationHaskellLibrary/blob/main/img/comparison_sqrt.png" alt="alt text" title="image Title" width="450"/>
 

Основываясь на примерах сверху, можно сделать следующие выводы:
1. Метод трапеций и метод Симпсона - вычисляют большое количество интегралов с минимаьной разницей на каждом шаге. Также этот вывод подтверждается тем, что внутри метода Симпсона используется вычисление методом трапеций с вдвое большим разбиением чем при том же разбиении в самом методе трапеций.
2.  Вычисления интеграла на меньшем разбиении (меньшее количество элементов дробления отрезка) способно дать достаточное количество информации, чтобы понять величину ошибки от корректного значения интеграла для текущего (большего) разбиения для интегралов без разрывов на отрезке интегрирования.
3.  Метод Симпсона - наиболее точный среди остальных (в среднем за меньшее количество шагов приходит к ближайшему ответу, в отличии от остальных)
4.  Методы Симпсона и трапеций имеют противоположный "характер приближения" к правильному ответу относительно метода прямоугольников: если первые два идут слева от значения, то метод прямоугольников идёт справа. И наоборот.
